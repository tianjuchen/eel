<!DOCTYPE html><head><meta charset="UTF-8"><title>Materials System | Stingray</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down" id="home-button">Stingray</a><a href="https://github.com/hugary1995/stingray" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="../../theory.html">Theory</a></li><li><a href="../../implementation.html">Implementation</a></li><li><a href="../../examples.html">Examples</a></li><li><a href="../../stingray.html">Documentation</a></li></ul><a href="#" class="sidenav-trigger" data-target="51060ae0-7e50-4698-9925-317b4f1c6af9"><i class="material-icons">menu</i></a><ul class="sidenav" id="51060ae0-7e50-4698-9925-317b4f1c6af9"><li><a href="../../theory.html">Theory</a></li><li><a href="../../implementation.html">Implementation</a></li><li><a href="../../examples.html">Examples</a></li><li><a href="../../stingray.html">Documentation</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">syntax</a><a href="." class="breadcrumb">Materials</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="5c94f23c-8b60-437e-b121-a72cc7a06642" data-section-level="1" data-section-text="Materials System"><h1 id="materials-system">Materials System</h1><p>The material system is the primary mechanism for defining spatially varying properties. The system allows properties to be defined in a single object (a <code>Material</code>) and shared among the many other systems such as the <a href="../Kernels/index.html">Kernel</a> or <a href="../BCs/index.html">BoundaryCondition</a> systems. Material objects are designed to directly couple to solution variables as well as other materials and therefore allow for capturing the true nonlinear behavior of the equations.</p><p>The material system relies on a producer/consumer relationship: <code>Material</code> objects <strong>produce</strong> properties and other objects (including materials) <strong>consume</strong> these properties.</p><p>The properties are produced on demand, thus the computed values are always up to date. For example, a property that relies on a solution variable (e.g., thermal conductivity as function of temperature) will be computed with the current temperature during the solve iterations, so the properties are tightly coupled.</p><p>The material system supports the use of automatic differentiation for property calculations, as such there are two approaches for producing and consuming properties: with and without automatic differentiation. The following sections detail the producing and consuming properties using the two approaches. To further understand automatic differentiation, please refer to the <a href="../../automatic_differentiation/index.html">Automatic Differentiation</a> page for more information.</p><p>The proceeding sections briefly describe the different aspects of a <code>Material</code> object for producing and computing the properties as well as how other objects consume the properties. For an example of how a <code>Material</code> object is created and used please refer to ex08_materials.md.</p><section class="scrollspy" id="bad0b500-1e7f-42a6-822c-2031803afa37" data-section-level="2" data-section-text="Producing / Computing Properties"><h2 id="producing-computing-properties">Producing/Computing Properties</h2><p>Properties must be produced by a <code>Material</code> object by declaring the property with one of two methods:</p><ol class="browser-default" start="1"><li><p><code>declareProperty&lt;TYPE&gt;(&quot;property_name&quot;)</code> declares a property with a name &quot;property_name&quot; to be computed by the <code>Material</code> object. </p></li><li><p><code>declareADProperty&lt;TYPE&gt;</code> declares a property with a name &quot;property_name&quot; to be computed by the <code>Material</code> object that will include automatic differentiation.</p></li></ol><p>The <code>TYPE</code> is any valid C++ type such an <code>int</code> or <code>Real</code> or <code>std::vector&lt;Real&gt;</code>. The properties must then be computed within the <code>computeQpProperties</code> method defined within the object.</p><p>The property name is an arbitrary name of the property, this name should be set such that it corresponds to the value be computed (e.g., &quot;diffusivity&quot;). The name provided here is the same name that will be used for consuming the property. More information on names is provided in <a href="index.html#property-names">Property Names</a> section below.</p><p>For example, consider a simulation that requires a diffusivity term. In the <code>Material</code> object header a property is declared (in the C++ since) as follows.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  MaterialProperty&lt;Real&gt; &amp; _diffusivity;
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#21292125-f022-40fe-8f76-4b45d44488a0">(moose/examples/ex08_materials/include/materials/ExampleMaterial.h)</a><p>All properties will either be a <code>MaterialProperty&lt;TYPE&gt;</code> or <code>ADMaterialProperty&lt;TYPE&gt;</code> and must be a non-const reference. Again, the <code>TYPE</code> can be any C++ type. In this example, a scalar <code>Real</code> number is being used.</p><p>In the source file the reference is initialized in the initialization list using the aforementioned declare functions as follows. This declares the property (in the material property sense) to be computed.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">    _diffusivity(declareProperty&lt;Real&gt;(&quot;diffusivity&quot;)),
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#bb203927-9810-41b8-9b1d-8d8d94d866a9">(moose/examples/ex08_materials/src/materials/ExampleMaterial.C)</a><p>The final step for producing a property is to compute the value. The computation occurs within a <code>Material</code> object <code>computeQpProperties</code> method. As the method name suggests, the purpose of the method is to compute the values of properties at a quadrature point. This method is a virtual method that must be overridden. To do this, in the header the virtual method is declared (again in the C++ sense).</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  virtual void computeQpProperties() override;
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#4352b232-eb99-4583-b4b5-e9b018ff38ee">(moose/examples/ex08_materials/include/materials/ExampleMaterial.h)</a><p>In the source file the method is defined. For the current example this definition computes the &quot;diffusivity&quot; as well another term, refer to ex08_materials.md.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">ExampleMaterial::computeQpProperties()
{
  // Diffusivity is the value of the interpolated piece-wise function described by the user
  _diffusivity[_qp] = _piecewise_func.sample(_q_point[_qp](2));

  // Convection velocity is set equal to the gradient of the variable set by the user.
  _convection_velocity[_qp] = _diffusion_gradient[_qp];
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#0143df39-68cc-45c6-afd8-1e36b5d05aec">(moose/examples/ex08_materials/src/materials/ExampleMaterial.C)</a><p>The purpose of the content of this method is to assign values for the properties at a quadrature point. Recall that &quot;_diffusivity&quot; is a reference to a <code>MaterialProperty</code> type. The <code>MaterialProperty</code> type is a container that stores the values of a property for each quadrature point. Therefore, this container must be indexed by <code>_qp</code> to compute the value for a specific quadrature point.</p></section><section class="scrollspy" id="16243602-fce1-420d-8833-5e67918eee3b" data-section-level="2" data-section-text="Consuming Properties"><h2 id="consuming-properties">Consuming Properties</h2><p>Objects that require material properties consume them using one of two functions</p><ol class="browser-default" start="1"><li><p><code>getMaterialProperty&lt;TYPE&gt;(&quot;property_name&quot;)</code> retrieves a property with a name &quot;property_name&quot; to be consumed by the object. </p></li><li><p><code>getADMaterialProperty&lt;TYPE&gt;(&quot;property_name&quot;)</code> retrieves a property with a name &quot;property_name&quot; to be consumed by the object that will include automatic differentiation.</p></li></ol><p>For an object to consume a property the same basic procedure is followed. First in the consuming objects header file a <code>MaterialProperty</code> with the correct type (e.g., <code>Real</code> for the diffusivity example) is declared (in the C++ sense) as follows. Notice, that the member variable is a <strong>const</strong> reference. The const is important. Consuming objects cannot modify a property, it only uses the property so it is marked to be constant.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  const MaterialProperty&lt;Real&gt; &amp; _diffusivity;
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#d2a97553-d521-42c2-ba51-1cb4025b51cd">(moose/examples/ex08_materials/include/kernels/ExampleDiffusion.h)</a><p>In the source file the reference is initialized in the initialization list using the aforementioned get methods. This method initializes the <code>_diffusivity</code> member variable to reference the desired value of the property as computed by the material object.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">  : Diffusion(parameters), _diffusivity(getMaterialProperty&lt;Real&gt;(&quot;diffusivity&quot;))
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#9b921341-5bbb-4b48-905d-1848910bb7ca">(moose/examples/ex08_materials/src/kernels/ExampleDiffusion.C)</a><p>The name used in the get method, &quot;diffusivity&quot;, in this case is not arbitrary. This name corresponds with the name used to declare the property in the material object.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>The declare/get calls must correspond</div><div class="card-content"><div class="moose-alert-content"><p>If a material property is declared for automatic differentiation (AD) using <code>declareADProperty</code> then it <strong>must</strong> be consumed with the <code>getADMaterialProperty</code>. The same is true for non-automatic differentiation; properties declared with <code>declareProperty</code> <strong>must</strong> be consumed with the <code>getMaterialProperty</code> method.</p></div></div></div><section id="90458ec3-ab11-4798-972f-d1d91d61cb57" data-section-level="3" data-section-text="Optional Properties"><h3 id="optional-properties">Optional Properties</h3><p>Objects can weakly couple to material properties that may or may not exist.</p><ol class="browser-default" start="1"><li><p><code>getOptionalMaterialProperty&lt;TYPE&gt;(&quot;property_name&quot;)</code> retrieves an optional property with a name &quot;property_name&quot; to be consumed by the object. </p></li><li><p><code>getOptionalADMaterialProperty&lt;TYPE&gt;(&quot;property_name&quot;)</code> retrieves an optional property with a name &quot;property_name&quot; to be consumed by the object that will include automatic differentiation.</p></li></ol><p>This API returns a reference to an optional material property (<code>OptionalMaterialProperty</code> or  <code>OptionalADMaterialProperty</code>). If the requested property is not provided by any material this reference will evaluate to <code>false</code>. It is the consuming object&#x27;s responsibility to check for this before accessing the material property data. Note that the state of the returned reference is only finalized _after_ all materials have been constructed, so a validity check must _not_ be made in the constructor of a material class but either at time of first use in <code>computeQpProperties</code> or in <code>initialSetup</code>.</p></section></section><section class="scrollspy" id="ed1d99d1-a78c-4ac6-83bf-89128ffd3aa1" data-section-level="2" data-section-text="Property Names"><h2 id="property-names">Property Names</h2><p>When creating a Material object and declaring the properties that shall be computed, it is often desirable to allow for the property name to be changed via the input file. This may be accomplished by adding an input parameter for assigning the name. For example, considering the example above the following code snippet adds an input parameter, &quot;diffusivity_name&quot;, that allows the input file to set the name of the diffusivity property, but by default the name remains &quot;diffusivity&quot;.</p><pre class="moose-pre"><code class="language-c++">
params.addParam&lt;MaterialPropertyName&gt;(&quot;diffusivity_name&quot;, &quot;diffusivity&quot;,
                                      &quot;The name of the diffusivity material property.&quot;);
</code></pre><p>In the material object, the declare function is simply changed to use the parameter name rather than string by itself. By default a property will be declared with the name &quot;diffusivity&quot;.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">    _diffusivity_name(declareProperty&lt;Real&gt;(&quot;diffusivity_name&quot;)),
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#41e5f30e-ba06-4b37-8686-473abb037566">(moose/examples/ex08_materials/src/materials/ExampleMaterial.C)</a><p>However, if the user wants to alter this name to something else, such as &quot;not_diffusivity&quot; then the input parameter &quot;diffusivity_name&quot; is simply added to the input file block for the material.</p><pre class="moose-pre"><code class="language-text">
[Materials]
  [example]
    type = ExampleMaterial
    diffusivity_name = not_diffusivity
  []
[]
</code></pre><p>On the consumer side, the get method will now be required to use the name &quot;not_diffusivity&quot; to retrieve the property. Consuming objects can also use the same procedure to allow for custom property names by adding a parameter and using the parameter name in the get method in the same fashion.</p></section><section class="scrollspy" id="39e0336f-fe42-4126-890a-c4a78541ff4f" data-section-level="2" data-section-text="Default Material Properties"><h2 id="default-material-properties">Default Material Properties</h2><p>The <code>MaterialPropertyName</code> input parameter also provides the ability to set default values for scalar (<code>Real</code>) properties. In the above example, the input file can use number or parsed function (see <a href="../../source/functions/MooseParsedFunction.html">ParsedFunction</a>) to define a the property value. For example, the input snippet above could set a constant value.</p><pre class="moose-pre"><code class="language-text">
[Materials]
  [example]
    type = ExampleMaterial
    diffusivity_name = 12345
  []
[]
</code></pre></section><section class="scrollspy" id="9d8404ef-23c6-440a-8f4f-2d2a2c4a2405" data-section-level="2" data-section-text="Stateful Material Properties"><h2 id="stateful-material-properties">Stateful Material Properties</h2><p>In general properties are computed on demand and not stored. However, in some cases values of material properties from a previous timestep may be required. To access properties two methods exist:</p><ul class="browser-default"><li><p><code>getMaterialPropertyOld&lt;TYPE&gt;</code> returns a reference to the property from the previous timestep. </p></li><li><p><code>getMaterialPropertyOlder&lt;TYPE&gt;</code> returns a reference to the property from two timesteps before the current.</p></li></ul><p>This is often referred to as a &quot;state&quot; variable, in MOOSE we refer to them as &quot;stateful material properties.&quot; As stated, material properties are usually computed on demand.</p><div class="card moose-alert moose-alert-warning"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">warning</i><span class="moose-alert-title-brand">warning:</span>Stateful properties will increase memory use</div><div class="card-content"><div class="moose-alert-content"><p>When a stateful property is requested through one of the above methods this is no longer the case. When it is computed the value is also stored for every quadrature point on every element. As such, stateful properties can become memory intensive, especially if the property being stored is a vector or tensor value.</p></div></div></div></section><section class="scrollspy" id="1da59727-891f-4ff0-acfb-2958c075ebcd" data-section-level="2" data-section-text="Material Property Output"><h2 id="material-property-output">Material Property Output</h2><p>Output of <code>Material</code> properties is enabled by setting the &quot;outputs&quot; parameter. The following example creates two additional variables called &quot;mat1&quot; and &quot;mat2&quot; that will show up in the output file.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[Materials]
  [block_1]
    type = OutputTestMaterial
    block = 1
    output_properties = &#x27;real_property tensor_property&#x27;
    outputs = exodus
    variable = u
  []
  [block_2]
    type = OutputTestMaterial
    block = 2
    output_properties = &#x27;vector_property tensor_property&#x27;
    outputs = exodus
    variable = u
  []
[]

[Outputs]
  exodus = true
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#6b6beb8c-f580-47c6-b302-7f11cf4e8b47">(moose/test/tests/materials/output/output_block.i)</a><p><code>Material</code> properties can be of arbitrary (C++) type, but not all types can be output. The following table lists the types of properties that are available for automatic output.</p><div form="['left', 'left', 'left']" recursive class="moose-table-div"><table><thead><tr><th style=";text-align:left">Type</th><th style=";text-align:left">AuxKernel</th><th style=";text-align:left">Variable Name(s)</th></tr></thead><tbody><tr><td style=";text-align:left">Real</td><td style=";text-align:left"><code>MaterialRealAux</code></td><td style=";text-align:left">prop</td></tr></tbody><tbody><tr><td style=";text-align:left">RealVectorValue</td><td style=";text-align:left"><code>MaterialRealVectorValueAux</code></td><td style=";text-align:left">prop_1, prop_2, and prop_3</td></tr></tbody><tbody><tr><td style=";text-align:left">RealTensorValue</td><td style=";text-align:left"><code>MaterialRealTensorValueAux</code></td><td style=";text-align:left">prop_11, prop_12, prop_13, prop_21, etc.</td></tr></tbody></table></div></section><section class="scrollspy" id="77c6cb13-0a5b-4dd3-b012-4043dac52122" data-section-level="2" data-section-text="Material sorting"><h2 id="material-sorting">Material sorting</h2><p>Materials are sorted such that one material may consume a property produced by another material and know that the consumed property will be up-to-date, e.g. the producer material will execute before the consumer material. If a cyclic dependency is detected between two materials, then MOOSE will produce an error.</p></section><section class="scrollspy" id="28e7a7f0-a862-4b31-b965-188f60da1f64" data-section-level="2" data-section-text="Functor Material Properties"><h2 id="functor-props">Functor Material Properties</h2><p>Functor material properties are properties that are evaluated on-the-fly. E.g. they can be viewed as functions of the current location in space (and time). Functor material properties provide several overloads of the <code>operator()</code> method for different &quot;geometric quantities&quot;. One example of a &quot;geometric quantity&quot; is a <code>const Elem *</code>, e.g. for an <code>FVElementalKernel</code>, the value of a functor material property in a cell-averaged sense can be obtained by the syntax</p><ul class="browser-default"><li><p><code>_foo(_current_elem)</code></p></li></ul><p>where here <code>_foo</code> is a functor material property data member of the kernel. The functor material property system introduces APIs very similar to the traditional material property system for declaring and getting properties. To declare a functor property:</p><ul class="browser-default"><li><p><code>declareFunctorProperty&lt;TYPE&gt;</code></p></li></ul><p>where <code>TYPE</code> can be anything such as <code>Real, ADReal, RealVectorValue, ADRealVectorValue</code> etc. To get a functor material property:</p><ul class="browser-default"><li><p><code>getFunctor&lt;TYPE&gt;</code></p></li></ul><p>It&#x27;s worth noting that whereas the traditional regular material property system has different methods to declare/get non-AD and AD properties, the new functor system has single APIs for both non-AD and AD property types.</p><p>Currently, functor material property evaluations are defined using the API:</p><pre class="moose-pre"><code class="language-c++">
template &lt;typename T&gt;
template &lt;typename PolymorphicLambda&gt;
void FunctorMaterialProperty&lt;T&gt;::
setFunctor(const MooseMesh &amp; mesh,
           const std::set&lt;SubdomainID&gt; &amp; block_ids,
           PolymorphicLambda my_lammy);
</code></pre><p>where the first two arguments are used to setup block restriction and the last argument is a lambda defining the property evaluation. The lambda must be callable with two arguments, the first corresponding to space, and the second corresponding to time, and must return the type <code>T</code> of the <code>FunctorMaterialProperty</code>. An example of setting a constant functor material property that returns an <code>ADReal</code> looks like:</p><pre class="moose-pre"><code class="language-c++">
    _constant_unity_prop.setFunctor(
        _mesh, blockIDs(), [](const auto &amp;, const auto &amp;) -&gt; ADReal { return 1.; });
</code></pre><p>An example of a functor material property that depends on a nonlinear variable would look like</p><pre class="moose-pre"><code class="language-c++">
    _u_prop.setFunctor(_mesh, blockIDs(), [this](const auto &amp; r, const auto &amp; t) -&gt; ADReal {
      return _u_var(r, t);
    });
</code></pre><p>In the above example, we simply forward the calling arguments along to the variable. Variable functor implementation is described in <a href="../../source/variables/MooseVariableBase.html#functor-vars">Variable functor evaluation</a>. A test functor material class to setup a dummy Euler problem is shown in</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">
#include &quot;ADCoupledVelocityMaterial.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, ADCoupledVelocityMaterial);

InputParameters
ADCoupledVelocityMaterial::validParams()
{
  InputParameters params = FunctorMaterial::validParams();
  params.addRequiredParam&lt;MooseFunctorName&gt;(&quot;vel_x&quot;, &quot;the x velocity&quot;);
  params.addParam&lt;MooseFunctorName&gt;(&quot;vel_y&quot;, &quot;the y velocity&quot;);
  params.addParam&lt;MooseFunctorName&gt;(&quot;vel_z&quot;, &quot;the z velocity&quot;);
  params.addRequiredParam&lt;MooseFunctorName&gt;(&quot;rho&quot;, &quot;The name of the density variable&quot;);
  params.addClassDescription(&quot;A material used to create a velocity from coupled variables&quot;);
  params.addParam&lt;MaterialPropertyName&gt;(
      &quot;velocity&quot;, &quot;velocity&quot;, &quot;The name of the velocity material property to create&quot;);
  params.addParam&lt;MaterialPropertyName&gt;(
      &quot;rho_u&quot;, &quot;rho_u&quot;, &quot;The product of the density and the x-velocity component&quot;);
  params.addParam&lt;MaterialPropertyName&gt;(
      &quot;rho_v&quot;, &quot;rho_v&quot;, &quot;The product of the density and the y-velocity component&quot;);
  params.addParam&lt;MaterialPropertyName&gt;(
      &quot;rho_w&quot;, &quot;rho_w&quot;, &quot;The product of the density and the z-velocity component&quot;);
  params += SetupInterface::validParams();
  params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;) = {EXEC_ALWAYS};
  return params;
}

ADCoupledVelocityMaterial::ADCoupledVelocityMaterial(const InputParameters &amp; parameters)
  : FunctorMaterial(parameters),
    _vel_x(getFunctor&lt;ADReal&gt;(&quot;vel_x&quot;)),
    _vel_y(isParamValid(&quot;vel_y&quot;) ? &amp;getFunctor&lt;ADReal&gt;(&quot;vel_y&quot;) : nullptr),
    _vel_z(isParamValid(&quot;vel_z&quot;) ? &amp;getFunctor&lt;ADReal&gt;(&quot;vel_z&quot;) : nullptr),
    _rho(getFunctor&lt;ADReal&gt;(&quot;rho&quot;))
{
  const std::set&lt;ExecFlagType&gt; clearance_schedule(_execute_enum.begin(), _execute_enum.end());

  addFunctorProperty&lt;ADRealVectorValue&gt;(
      getParam&lt;MaterialPropertyName&gt;(&quot;velocity&quot;),
      [this](const auto &amp; r, const auto &amp; t) -&gt; ADRealVectorValue
      {
        ADRealVectorValue velocity(_vel_x(r, t));
        velocity(1) = _vel_y ? (*_vel_y)(r, t) : ADReal(0);
        velocity(2) = _vel_z ? (*_vel_z)(r, t) : ADReal(0);
        return velocity;
      },
      clearance_schedule);

  addFunctorProperty&lt;ADReal&gt;(
      getParam&lt;MaterialPropertyName&gt;(&quot;rho_u&quot;),
      [this](const auto &amp; r, const auto &amp; t) -&gt; ADReal { return _rho(r, t) * _vel_x(r, t); },
      clearance_schedule);

  addFunctorProperty&lt;ADReal&gt;(
      getParam&lt;MaterialPropertyName&gt;(&quot;rho_v&quot;),
      [this](const auto &amp; r, const auto &amp; t) -&gt; ADReal
      { return _vel_y ? _rho(r, t) * (*_vel_y)(r, t) : ADReal(0); },
      clearance_schedule);

  addFunctorProperty&lt;ADReal&gt;(
      getParam&lt;MaterialPropertyName&gt;(&quot;rho_w&quot;),
      [this](const auto &amp; r, const auto &amp; t) -&gt; ADReal
      { return _vel_z ? _rho(r, t) * (*_vel_z)(r, t) : ADReal(0); },
      clearance_schedule);
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#ee73c8e5-ca1b-4f9e-90f5-9b44e22a1a90">(moose/test/src/materials/ADCoupledVelocityMaterial.C)</a><p>In the following subsections, we describe the various spatial arguments that functor (material properties) can be evaluated at. Almost no functor material developers should have to concern themselves with these details as most material property functions should just appear as functions of space and time, e.g. the same lambda defining the property evaluation should apply across all spatial and temporal arguments. However, in the case that a functor material developer wishes to create specific implementations for specific arguments (as illustrated in <code>IMakeMyOwnFunctorProps</code> test class) or simply wishes to know more about the system, we give the details below.</p><p>Any call to a functor (material property) looks like the following <code>_foo(const SpatialArg &amp; r, const TemporalArg &amp; t)</code>. Below are the possible type overloads of <code>SpatialArg</code>.</p><section id="76f8adae-5166-4724-a194-13fd2f56db16" data-section-level="3" data-section-text="FaceArg"><h3 id="spatial-overloads">FaceArg</h3><p>A typedef defining a &quot;face&quot; evaluation calling argument. This is composed of</p><ul class="browser-default"><li><p>a face information object which defines our location in space </p></li><li><p>a limiter which defines how the functor evaluated on either side of the face should be interpolated to the face </p></li><li><p>a boolean which states whether the face information element is upwind of the face </p></li><li><p>a pair of subdomain IDs. These do not always correspond to the face info element subdomain ID and face info neighbor subdomain ID. For instance if a flux kernel is operating at a subdomain boundary on which the kernel is defined on one side but not the other, the passed-in subdomain IDs will both correspond to the subdomain ID that the flux kernel is defined on</p></li></ul></section><section id="ae4c1cb8-a73a-4c22-bf18-b01557256934" data-section-level="3" data-section-text="ElemFromFaceArg"><h3 id="elemfromfacearg">ElemFromFaceArg</h3><p>People should think of this geometric argument as corresponding to the location in space of the provided element centroid, <em>not</em> as corresonding to the location of the provided face information. Summary of data in this argument:</p><ul class="browser-default"><li><p>an element, whose centroid we should think of as the evaluation point. It is possible that the element will be a nullptr in which case, the evaluation point should be thought of as the location of a ghosted element centroid </p></li><li><p>a face information object. When the provided element is null or for instance when the functoris a variable that does not exist on the provided element subdomain, this face information object will be used to help construct a ghost value evaluation </p></li><li><p>a subdomain ID. This is useful when the functor is a material property and the user wants to indicate which material property definition should be used to evaluate the functor. For instance if we are using a flux kernel that is not defined on one side of the face, the subdomain ID will allow us to compute a ghost material property evaluation</p></li></ul></section><section id="951326d5-f85e-426d-91ea-4e4f5655fa09" data-section-level="3" data-section-text="ElemQpArg"><h3 id="elemqparg">ElemQpArg</h3><p>Argument for requesting functor evaluation at a quadrature point location in an element. Data in the argument:</p><ul class="browser-default"><li><p>The element containing the quadrature point </p></li><li><p>The quadrature point index, e.g. if there are <code>n</code> quadrature points, we are requesting the evaluation of the ith point </p></li><li><p>The quadrature rule that can be used to initialize the functor on the given element</p></li></ul><p>If functor material properties are functions of nonlinear degrees of freedom, evaluation with this argument will likely result in calls to libMesh <code>FE::reinit</code>.</p></section><section id="f994f744-cf92-440c-bf6d-2a027b87e2dc" data-section-level="3" data-section-text="ElemSideQpArg"><h3 id="elemsideqparg">ElemSideQpArg</h3><p>Argument for requesting functor evaluation at quadrature point locations on an element side. Data in the argument:</p><ul class="browser-default"><li><p>The element </p></li><li><p>The element side on which the quadrature points are located </p></li><li><p>The quadrature point index, e.g. if there are <code>n</code> quadrature points, we are requesting the evaluation of the ith point </p></li><li><p>The quadrature rule that can be used to initialize the functor on the given element and side</p></li></ul><p>If functor material properties are functions of nonlinear degrees of freedom, evaluation with this argument will likely result in calls to libMesh <code>FE::reinit</code>.</p></section><section id="78b61a8b-0784-4331-bf10-9798a03a5855" data-section-level="3" data-section-text="Functor caching"><h3 id="functor-caching">Functor caching</h3><p>By default, functor material properties are always (re-)evaluated every time they are called with <code>operator()</code>. However, the base class that <code>FunctorMaterialProperty</code> inherits from, <code>Moose::Functor</code>, has a <code>setCacheClearanceSchedule(const std::set&lt;ExecFlagType&gt; &amp; clearance_schedule)</code> API that allows control of evaluations. Supported values for the <code>clearance_schedule</code> are any combination of <code>EXEC_ALWAYS</code>, <code>EXEC_TIMESTEP_BEGIN</code>, <code>EXEC_LINEAR</code>, and <code>EXEC_NONLINEAR</code>. These will cause cached evaluations of functor (material properties) to be cleared always (in fact not surprisingly in this case we never fill the cache), on <code>timestepSetup</code>, on <code>residualSetup</code>, and on <code>jacobianSetup</code> respectively. If a functor is expected to depend on nonlinear degrees of freedom, then the cache should be cleared on <code>EXEC_LINEAR</code> and <code>EXEC_NONLINEAR</code> (the default <code>EXEC_ALWAYS</code> would obviously also work) in order to achieve a perfect Jacobian. Not surprisingly, if a functor evaluation is cached, then memory usage will increase.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note:</span>Caching Implementations</div><div class="card-content"><div class="moose-alert-content"><p>Functor caching is only currently implemented for <code>ElemQpArg</code> and <code>ElemSideQpArg</code> spatial overloads. This is with the idea that calls to <code>FE::reinit</code> can be fairly expensive whereas for the other spatial argument types, evaluation of the functor (material property) may be relatively inexpensive compared to the memory expense incurred from caching. We may definitely implement caching for other overloads, however, if use cases call for it.</p></div></div></div></section></section><section class="scrollspy" id="52a46f80-c8f9-4b90-a37c-8ae240b8921f" data-section-level="2" data-section-text="Advanced Topics"><h2 id="advanced-topics">Advanced Topics</h2><section id="4b4cf5d6-305e-4087-bdf7-85b43e4ce2f4" data-section-level="3" data-section-text="Evaluation of Material Properties on Element Faces"><h3 id="evaluation-of-material-properties-on-element-faces">Evaluation of Material Properties on Element Faces</h3><p>MOOSE creates three copies of a <em>non-boundary restricted</em> material for evaluations on quadrature points of elements, element faces on both the current element side and the neighboring element side. The name of the element interior material is the material name from the input file, while the name of the element face material is the material name appended with <code>_face</code> and the name of the neighbor face material is the material name appended with <code>_neighbor</code>. The element material can be identified in a material with its member variable <code>_bnd=false</code>. The other two copies have <code>_bnd=true</code>. The element face material and neighbor face material differentiate with each other by the value of another member variable <code>_neighbor</code>. If a material declares multiple material properties and some of them are not needed on element faces, users can switch off their declaration and evaluation based on member variable <code>_bnd</code>.</p></section><section id="3e7c8d8e-a2ea-48d0-b33e-2bb5df5a67de" data-section-level="3" data-section-text="Interface Material Objects"><h3 id="interface-material-objects">Interface Material Objects</h3><p>MOOSE allows a material to be defined on an internal boundary of a mesh with a specific material type <code>InterfaceMaterial</code>. Material properties declared in interface materials are available on both sides of the boundary. Interface materials allows users to evaluate the properties on element faces based on quantities on both sides of the element face. Interface materials are often used along with <a href="../InterfaceKernels/index.html">InterfaceKernel</a>.</p></section><section id="b441179a-7b1b-4ebc-a974-f1700798c8d3" data-section-level="3" data-section-text="Discrete Material Objects"><h3 id="discrete-material-objects">Discrete Material Objects</h3><p>A &quot;<a href="http://www.dictionary.com/browse/discrete">Discrete</a>&quot; <code>Material</code> is an object that may be detached from MOOSE and computed explicitly from other objects. An object inheriting from <a href="http://www.mooseframework.org/docs/doxygen/moose/classMaterialPropertyInterface.html">MaterialPropertyInterface</a> may explicitly call the compute methods of a <code>Material</code> object via the <code>getMaterial</code> method.</p><p>The following should be considered when computing <code>Material</code> properties explicitly.</p><ul class="browser-default"><li><p>It is possible to disable the automatic computation of a <code>Material</code> object by MOOSE by setting the <code>compute=false</code> parameter. </p></li><li><p>When <code>compute=false</code> is set the compute method (<code>computeQpProperties</code>) is <strong>not</strong> called by MOOSE, instead it must be called explicitly in your application using the <code>computeProperties</code> method that accepts a quadrature point index. </p></li><li><p>When <code>compute=false</code> an additional method should be defined, <code>resetQpProperties</code>, which sets the properties to a safe value (e.g., 0) for later calls to the compute method. Not doing this can lead to erroneous material properties values.</p></li></ul><p>The original intent for this functionality was to enable to ability for material properties to be computed via iteration by another object, as in the following example. First, consider define a material (<code>RecomputeMaterial</code>) that computes the value of a function and its derivative.</p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-e0580c36-7e9b-47e7-9fb4-205766ff429b"></span><script>var element = document.getElementById("moose-equation-e0580c36-7e9b-47e7-9fb4-205766ff429b");katex.render("f(p) = p^2v", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span><p>and</p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-e6e954a5-4a0b-417e-b006-6c365326b5b1"></span><script>var element = document.getElementById("moose-equation-e6e954a5-4a0b-417e-b006-6c365326b5b1");katex.render("f'(p) = 2pv,", element, {displayMode:true,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span><p>where v is known value and not a function of p. The following is the compute portion of this object.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">void
RecomputeMaterial::computeQpProperties()
{
  Real x = _p[_qp];
  _f[_qp] = x * x - _constant;
  _f_prime[_qp] = 2 * x;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#b40d9f0f-31bf-4ff3-9f4b-09b8bdefa564">(moose/test/src/materials/RecomputeMaterial.C)</a><p>Second, define another material (<code>NewtonMaterial</code>) that computes the value of <span class="moose-katex-inline-equation" id="moose-equation-807d50a5-8d18-48e9-865a-a28618dba851"><script>var element = document.getElementById("moose-equation-807d50a5-8d18-48e9-865a-a28618dba851");katex.render("p: f(p)=0", element, {displayMode:false,throwOnError:false,macros:{"\\bs":"\\boldsymbol{#1}","\\grad":"\\bs{\\nabla}","\\divergence":"\\grad \\cdot","\\norm":"\\left\\lVert#1\\right\\rVert","\\abs":"\\left\\lvert#1\\right\\rvert","\\diff":"\\text{ d}#1","\\bfa":"\\boldsymbol{a}","\\bfb":"\\boldsymbol{b}","\\bfc":"\\boldsymbol{c}","\\bfd":"\\boldsymbol{d}","\\bfe":"\\boldsymbol{e}","\\bff":"\\boldsymbol{f}","\\bfg":"\\boldsymbol{g}","\\bfh":"\\boldsymbol{h}","\\bfi":"\\boldsymbol{i}","\\bfj":"\\boldsymbol{j}","\\bfk":"\\boldsymbol{k}","\\bfl":"\\boldsymbol{l}","\\bfm":"\\boldsymbol{m}","\\bfn":"\\boldsymbol{n}","\\bfo":"\\boldsymbol{o}","\\bfp":"\\boldsymbol{p}","\\bfq":"\\boldsymbol{q}","\\bfr":"\\boldsymbol{r}","\\bfs":"\\boldsymbol{s}","\\bft":"\\boldsymbol{t}","\\bfu":"\\boldsymbol{u}","\\bfv":"\\boldsymbol{v}","\\bfw":"\\boldsymbol{w}","\\bfx":"\\boldsymbol{x}","\\bfy":"\\boldsymbol{y}","\\bfz":"\\boldsymbol{z}","\\bfA":"\\boldsymbol{A}","\\bfB":"\\boldsymbol{B}","\\bfC":"\\boldsymbol{C}","\\bfD":"\\boldsymbol{D}","\\bfE":"\\boldsymbol{E}","\\bfF":"\\boldsymbol{F}","\\bfG":"\\boldsymbol{G}","\\bfH":"\\boldsymbol{H}","\\bfI":"\\boldsymbol{I}","\\bfJ":"\\boldsymbol{J}","\\bfK":"\\boldsymbol{K}","\\bfL":"\\boldsymbol{L}","\\bfM":"\\boldsymbol{M}","\\bfN":"\\boldsymbol{N}","\\bfO":"\\boldsymbol{O}","\\bfP":"\\boldsymbol{P}","\\bfQ":"\\boldsymbol{Q}","\\bfR":"\\boldsymbol{R}","\\bfS":"\\boldsymbol{S}","\\bfT":"\\boldsymbol{T}","\\bfU":"\\boldsymbol{U}","\\bfV":"\\boldsymbol{V}","\\bfW":"\\boldsymbol{W}","\\bfX":"\\boldsymbol{X}","\\bfY":"\\boldsymbol{Y}","\\bfZ":"\\boldsymbol{Z}"}});</script></span> using Newton iterations. This material declares a material property (<code>_p</code>) which is what is solved for by iterating on the material properties containing <code>f</code> and <code>f&#x27;</code> from <code>RecomputeMaterial</code>. The <code>_discrete</code> member is a reference to a <code>Material</code> object retrieved with <code>getMaterial</code>.</p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">// MOOSEDOCS_START
void
NewtonMaterial::computeQpProperties()
{
  _p[_qp] = 0.5; // initial guess

  // Newton iteration for find p
  for (unsigned int i = 0; i &lt; _max_iterations; ++i)
  {
    _discrete-&gt;computePropertiesAtQp(_qp);
    _p[_qp] -= _f[_qp] / _f_prime[_qp];
    if (std::abs(_f[_qp]) &lt; _tol)
      break;
  }
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#82d1e30d-d320-46a2-9bc2-a35c95933fb9">(moose/test/src/materials/NewtonMaterial.C)</a><p>To create and use a &quot;Discrete&quot; <code>Material</code> use the following to guide the process.</p><ol class="browser-default" start="1"><li><p>Create a <code>Material</code> object by, in typical MOOSE fashion, inheriting from the <code>Material</code> object in your own application. </p></li><li><p>In your input file, set <code>compute=false</code> for this new object. </p></li><li><p>From within another object (e.g., another Material) that inherits from <code>MaterialPropertyInterface</code> call the <code>getMaterial</code> method. Note, this method returns a reference to a <code>Material</code> object, be sure to include <code>&amp;</code> when calling or declaring the variable. </p></li><li><p>When needed, call the <code>computeProperties</code> method of the <code>Material</code> being sure to provide the current quadrature point index to the method (<code>_qp</code> in most cases).</p></li></ol></section></section><section class="scrollspy" id="2dae7c89-ee30-4553-8ede-90c80e7c3f34" data-section-level="2" data-section-text="Available Objects"><h2 id="available-objects">Available Objects</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/materials/CoupledValueFunctionMaterial.html">ADCoupledValueFunctionMaterial</a>Compute a function value from coupled variables</li><li class="collection-item"><a href="../../source/materials/DerivativeParsedMaterial.html">ADDerivativeParsedMaterial</a>Parsed Function Material with automatic derivatives.</li><li class="collection-item"><a href="../../source/materials/DerivativeSumMaterial.html">ADDerivativeSumMaterial</a>Meta-material to sum up multiple derivative materials</li><li class="collection-item"><a href="../../source/materials/GenericFunctorMaterial.html">ADGenericConstantFunctorMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of a Functor (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="../../source/materials/GenericConstantMaterial.html">ADGenericConstantMaterial</a>Declares material properties based on names and values prescribed by input parameters.</li><li class="collection-item"><a href="../../source/materials/GenericConstantRankTwoTensor.html">ADGenericConstantRankTwoTensor</a>Object for declaring a constant rank two tensor as a material property.</li><li class="collection-item"><a href="../../source/materials/GenericVectorFunctorMaterial.html">ADGenericConstantVectorFunctorMaterial</a>FunctorMaterial object for declaring vector properties that are populated by evaluation of functor (constants, functions, variables, matprops) object.</li><li class="collection-item"><a href="../../source/materials/GenericConstantVectorMaterial.html">ADGenericConstantVectorMaterial</a>Declares material properties based on names and vector values prescribed by input parameters.</li><li class="collection-item"><a href="../../source/materials/GenericFunctorMaterial.html">ADGenericFunctionFunctorMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of a Functor (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="../../source/materials/GenericFunctionMaterial.html">ADGenericFunctionMaterial</a>Material object for declaring properties that are populated by evaluation of Function object.</li><li class="collection-item"><a href="../../source/materials/GenericFunctionRankTwoTensor.html">ADGenericFunctionRankTwoTensor</a>Material object for defining rank two tensor properties using functions.</li><li class="collection-item"><a href="../../source/materials/GenericFunctionVectorMaterial.html">ADGenericFunctionVectorMaterial</a>Material object for declaring vector properties that are populated by evaluation of Function objects.</li><li class="collection-item"><a href="../../source/materials/GenericFunctorGradientMaterial.html">ADGenericFunctorGradientMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of gradients of Functors (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="../../source/materials/GenericFunctorMaterial.html">ADGenericFunctorMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of a Functor (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="../../source/materials/GenericVectorFunctorMaterial.html">ADGenericVectorFunctorMaterial</a>FunctorMaterial object for declaring vector properties that are populated by evaluation of functor (constants, functions, variables, matprops) object.</li><li class="collection-item"><a href="../../source/materials/ParsedMaterial.html">ADParsedMaterial</a>Parsed Function Material.</li><li class="collection-item"><a href="../../source/materials/PiecewiseByBlockFunctorMaterial.html">ADPiecewiseByBlockFunctorMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="../../source/materials/PiecewiseByBlockFunctorMaterial.html">ADPiecewiseByBlockVectorFunctorMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="../../source/materials/PiecewiseConstantByBlockMaterial.html">ADPiecewiseConstantByBlockMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="../../source/materials/ADPiecewiseLinearInterpolationMaterial.html">ADPiecewiseLinearInterpolationMaterial</a>Compute a property using a piecewise linear interpolation to define its dependence on a variable</li><li class="collection-item"><a href="../../source/materials/VectorMagnitudeFunctorMaterial.html">ADVectorMagnitudeFunctorMaterial</a>This class takes up to three scalar-valued functors corresponding to vector components <em>or</em> a single vector functor and computes the Euclidean norm.</li><li class="collection-item"><a href="../../source/materials/CoupledValueFunctionMaterial.html">CoupledValueFunctionMaterial</a>Compute a function value from coupled variables</li><li class="collection-item"><a href="../../source/materials/DerivativeParsedMaterial.html">DerivativeParsedMaterial</a>Parsed Function Material with automatic derivatives.</li><li class="collection-item"><a href="../../source/materials/DerivativeSumMaterial.html">DerivativeSumMaterial</a>Meta-material to sum up multiple derivative materials</li><li class="collection-item"><a href="../../source/materials/PiecewiseByBlockFunctorMaterial.html">FVADPropValPerSubdomainMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="../../source/materials/PiecewiseByBlockFunctorMaterial.html">FVPropValPerSubdomainMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="../../source/materials/FunctorADConverter.html">FunctorADConverter</a>Converts regular functors to AD functors and AD functors to regular functors</li><li class="collection-item"><a href="../../source/materials/GenericConstant2DArray.html">GenericConstant2DArray</a>A material evaluating one material property in type of RealEigenMatrix</li><li class="collection-item"><a href="../../source/materials/GenericConstantArray.html">GenericConstantArray</a>A material evaluating one material property in type of RealEigenVector</li><li class="collection-item"><a href="../../source/materials/GenericFunctorMaterial.html">GenericConstantFunctorMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of a Functor (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="../../source/materials/GenericConstantMaterial.html">GenericConstantMaterial</a>Declares material properties based on names and values prescribed by input parameters.</li><li class="collection-item"><a href="../../source/materials/GenericConstantRankTwoTensor.html">GenericConstantRankTwoTensor</a>Object for declaring a constant rank two tensor as a material property.</li><li class="collection-item"><a href="../../source/materials/GenericVectorFunctorMaterial.html">GenericConstantVectorFunctorMaterial</a>FunctorMaterial object for declaring vector properties that are populated by evaluation of functor (constants, functions, variables, matprops) object.</li><li class="collection-item"><a href="../../source/materials/GenericConstantVectorMaterial.html">GenericConstantVectorMaterial</a>Declares material properties based on names and vector values prescribed by input parameters.</li><li class="collection-item"><a href="../../source/materials/GenericFunctorMaterial.html">GenericFunctionFunctorMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of a Functor (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="../../source/materials/GenericFunctionMaterial.html">GenericFunctionMaterial</a>Material object for declaring properties that are populated by evaluation of Function object.</li><li class="collection-item"><a href="../../source/materials/GenericFunctionRankTwoTensor.html">GenericFunctionRankTwoTensor</a>Material object for defining rank two tensor properties using functions.</li><li class="collection-item"><a href="../../source/materials/GenericFunctionVectorMaterial.html">GenericFunctionVectorMaterial</a>Material object for declaring vector properties that are populated by evaluation of Function objects.</li><li class="collection-item"><a href="../../source/materials/GenericFunctorGradientMaterial.html">GenericFunctorGradientMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of gradients of Functors (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="../../source/materials/GenericFunctorMaterial.html">GenericFunctorMaterial</a>FunctorMaterial object for declaring properties that are populated by evaluation of a Functor (a constant, variable, function or functor material property) objects.</li><li class="collection-item"><a href="../../source/materials/GenericVectorFunctorMaterial.html">GenericVectorFunctorMaterial</a>FunctorMaterial object for declaring vector properties that are populated by evaluation of functor (constants, functions, variables, matprops) object.</li><li class="collection-item"><a href="../../source/materials/MaterialADConverter.html">MaterialADConverter</a>Converts regular material properties to AD properties and vice versa</li><li class="collection-item"><a href="../../source/materials/MaterialADConverter.html">MaterialConverter</a>Converts regular material properties to AD properties and vice versa</li><li class="collection-item"><a href="../../source/materials/ParsedMaterial.html">ParsedMaterial</a>Parsed Function Material.</li><li class="collection-item"><a href="../../source/materials/PiecewiseByBlockFunctorMaterial.html">PiecewiseByBlockFunctorMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="../../source/materials/PiecewiseByBlockFunctorMaterial.html">PiecewiseByBlockVectorFunctorMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="../../source/materials/PiecewiseConstantByBlockMaterial.html">PiecewiseConstantByBlockMaterial</a>Computes a property value on a per-subdomain basis</li><li class="collection-item"><a href="../../source/materials/PiecewiseLinearInterpolationMaterial.html">PiecewiseLinearInterpolationMaterial</a>Compute a property using a piecewise linear interpolation to define its dependence on a variable</li><li class="collection-item"><a href="../../source/materials/MaterialADConverter.html">RankFourTensorMaterialADConverter</a>Converts regular material properties to AD properties and vice versa</li><li class="collection-item"><a href="../../source/materials/MaterialADConverter.html">RankFourTensorMaterialConverter</a>Converts regular material properties to AD properties and vice versa</li><li class="collection-item"><a href="../../source/materials/MaterialADConverter.html">RankTwoTensorMaterialADConverter</a>Converts regular material properties to AD properties and vice versa</li><li class="collection-item"><a href="../../source/materials/MaterialADConverter.html">RankTwoTensorMaterialConverter</a>Converts regular material properties to AD properties and vice versa</li><li class="collection-item"><a href="../../source/materials/FunctorADConverter.html">VectorFunctorADConverter</a>Converts regular functors to AD functors and AD functors to regular functors</li><li class="collection-item"><a href="../../source/materials/VectorMagnitudeFunctorMaterial.html">VectorMagnitudeFunctorMaterial</a>This class takes up to three scalar-valued functors corresponding to vector components <em>or</em> a single vector functor and computes the Euclidean norm.</li><li class="collection-header">Heat Conduction App</li><li class="collection-item"><a href="../../source/materials/AnisoHeatConductionMaterial.html">ADAnisoHeatConductionMaterial</a>General-purpose material model for anisotropic heat conduction</li><li class="collection-item"><a href="../../source/materials/ElectricalConductivity.html">ADElectricalConductivity</a>Calculates resistivity and electrical conductivity as a function of temperature, using copper for parameter defaults.</li><li class="collection-item"><a href="../../source/materials/HeatConductionMaterial.html">ADHeatConductionMaterial</a>General-purpose material model for heat conduction</li><li class="collection-item"><a href="../../source/materials/AnisoHeatConductionMaterial.html">AnisoHeatConductionMaterial</a>General-purpose material model for anisotropic heat conduction</li><li class="collection-item"><a href="../../source/materials/ElectricalConductivity.html">ElectricalConductivity</a>Calculates resistivity and electrical conductivity as a function of temperature, using copper for parameter defaults.</li><li class="collection-item"><a href="../../source/materials/FunctionPathEllipsoidHeatSource.html">FunctionPathEllipsoidHeatSource</a>Double ellipsoid volumetric source heat with function path.</li><li class="collection-item"><a href="../../source/materials/GapConductance.html">GapConductance</a></li><li class="collection-item"><a href="../../source/materials/GapConductanceConstant.html">GapConductanceConstant</a>Material to compute a constant, prescribed gap conductance</li><li class="collection-item"><a href="../../source/materials/HeatConductionMaterial.html">HeatConductionMaterial</a>General-purpose material model for heat conduction</li><li class="collection-item"><a href="../../source/materials/SemiconductorLinearConductivity.html">SemiconductorLinearConductivity</a>Calculates electrical conductivity of a semiconductor from temperature</li><li class="collection-item"><a href="../../source/materials/SideSetHeatTransferMaterial.html">SideSetHeatTransferMaterial</a>This material constructs the necessary coefficients and properties for SideSetHeatTransferKernel.</li><li class="collection-header">Stingray App</li><li class="collection-item"><a href="../../source/materials/chemistry/Charging.html">Charging</a>This class computes the chemical energy density and its corresponding thermodynamic forces. We assume the chemical energy density depends on at least the deformation gradient, the concentrations and the gradients of concentrations. This class defines the mass transport of a charged species driven by electric potential.</li><li class="collection-item"><a href="../../source/materials/kinematics/DeformationGradient.html">DeformationGradient</a>This class computes the deformation gradient. Eigen deformation gradients are extracted from the total deformation gradient. The F-bar approach can optionally be used to correct volumetric locking.</li><li class="collection-item"><a href="../../source/materials/forces/ElectricDisplacement.html">ElectricDisplacement</a>This class computes the electric displacement associated with given energy densities.</li><li class="collection-item"><a href="../../source/materials/chemistry/FicksFirstLaw.html">FicksFirstLaw</a>This class computes the chemical energy density and its corresponding thermodynamic forces. We assume the chemical energy density depends on at least the deformation gradient, the concentrations and the gradients of concentrations. This class defines the Fick&#x27;s first law.</li><li class="collection-item"><a href="../../source/materials/forces/FirstPiolaKirchhoffStress.html">FirstPiolaKirchhoffStress</a>This class computes the first Piola-Kirchhoff stress associated with given energy densities.</li><li class="collection-item"><a href="../../source/materials/electrostatics/JouleHeating.html">JouleHeating</a>This class computes volumetric heat source due to Joule heating from electric displacement.</li><li class="collection-item"><a href="../../source/materials/forces/MassFlux.html">MassFlux</a>This class computes the mass flux associated with given energy densities for a given species.</li><li class="collection-item"><a href="../../source/materials/forces/MassSource.html">MassSource</a>This class computes the mass source associated with given energy densities for a given species.</li><li class="collection-item"><a href="../../source/materials/mechanics/NeoHookeanElasticEnergyDensity.html">NeoHookeanElasticEnergyDensity</a>This class computes the elastic energy density and its corresponding thermodynamic forces. We assume the elastic energy density depends on at least the deformation gradient and the concentrations. This class defines the Neo-Hookean elastic energy density.</li><li class="collection-item"><a href="../../source/materials/electrostatics/Polarization.html">Polarization</a>This class computes the electrical energy density and its corresponding thermodynamic forces. We assume the electrical energy density depends on at least the deformation gradient and the gradient of electrical potential This class defines the electrical polarization potential.</li><li class="collection-item"><a href="../../source/materials/kinematics/SwellingDeformationGradient.html">SwellingDeformationGradient</a>This class computes the eigen deformation gradient due to swelling.</li><li class="collection-item"><a href="../../source/materials/kinematics/ThermalDeformationGradient.html">ThermalDeformationGradient</a>This class computes the thermal deformation gradient based on the instantaneous CTE.</li><li class="collection-item"><a href="../../source/materials/chemistry/ViscousMassTransport.html">ViscousMassTransport</a>This class computes the chemical dissipation density and its corresponding thermodynamic forces. We assume the chemical energy density depends on at least the rate of change of the concentrations and their gradients. This class defines the viscous dissipation in mass transport.</li></ul></section><section class="scrollspy" id="c09195b6-774f-4f05-bcb9-c7ec69e9cee8" data-section-level="2" data-section-text="Available Actions"><h2 id="available-actions">Available Actions</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/actions/AddMaterialAction.html">AddMaterialAction</a>Add a Material object to the simulation.</li></ul></section></section><div class="moose-modal modal" id="21292125-f022-40fe-8f76-4b45d44488a0"><div class="modal-content"><h4>(moose/examples/ex08_materials/include/materials/ExampleMaterial.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;Material.h&quot;
#include &quot;LinearInterpolation.h&quot;

class ExampleMaterial : public Material
{
public:
  ExampleMaterial(const InputParameters &amp; parameters);

  static InputParameters validParams();

protected:
  virtual void computeQpProperties() override;

private:
  /// member variable to hold the computed diffusivity coefficient
  MaterialProperty&lt;Real&gt; &amp; _diffusivity;
  /// member variable to hold the computed convection velocity gradient term
  MaterialProperty&lt;RealGradient&gt; &amp; _convection_velocity;

  /// A place to store the coupled variable gradient for calculating the convection velocity
  /// property.
  const VariableGradient &amp; _diffusion_gradient;

  /// A helper object for performaing linear interpolations on tabulated data for calculating the
  /// diffusivity property.
  LinearInterpolation _piecewise_func;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="bb203927-9810-41b8-9b1d-8d8d94d866a9"><div class="modal-content"><h4>(moose/examples/ex08_materials/src/materials/ExampleMaterial.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ExampleMaterial.h&quot;

registerMooseObject(&quot;ExampleApp&quot;, ExampleMaterial);

InputParameters
ExampleMaterial::validParams()
{
  InputParameters params = Material::validParams();

  // Allow users to specify vectors defining the points of a piecewise function formed via linear
  // interpolation.
  params.addRequiredParam&lt;std::vector&lt;Real&gt;&gt;(
      &quot;independent_vals&quot;,
      &quot;The vector of z-coordinate values for a piecewise function&#x27;s independent variable&quot;);
  params.addRequiredParam&lt;std::vector&lt;Real&gt;&gt;(
      &quot;dependent_vals&quot;, &quot;The vector of diffusivity values for a piecewise function&#x27;s dependent&quot;);

  // Allow the user to specify which independent variable&#x27;s gradient to use for calculating the
  // convection velocity property:
  params.addCoupledVar(
      &quot;diffusion_gradient&quot;,
      &quot;The gradient of this variable will be used to compute a velocity vector property.&quot;);

  return params;
}

ExampleMaterial::ExampleMaterial(const InputParameters &amp; parameters)
  : Material(parameters),
    // Declare that this material is going to provide a Real value typed
    // material property named &quot;diffusivity&quot; that Kernels and other objects can use.
    // This property is &quot;bound&quot; to the class&#x27;s &quot;_diffusivity&quot; member.
    _diffusivity(declareProperty&lt;Real&gt;(&quot;diffusivity&quot;)),

    // Also declare a second &quot;convection_velocity&quot; RealGradient value typed property.
    _convection_velocity(declareProperty&lt;RealGradient&gt;(&quot;convection_velocity&quot;)),

    // Get the reference to the variable coupled into this Material.
    _diffusion_gradient(isCoupled(&quot;diffusion_gradient&quot;) ? coupledGradient(&quot;diffusion_gradient&quot;)
                                                        : _grad_zero),

    // Initialize our piecewise function helper with the user-specified interpolation points.
    _piecewise_func(getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;independent_vals&quot;),
                    getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;dependent_vals&quot;))
{
}

void
ExampleMaterial::computeQpProperties()
{
  // Diffusivity is the value of the interpolated piece-wise function described by the user
  _diffusivity[_qp] = _piecewise_func.sample(_q_point[_qp](2));

  // Convection velocity is set equal to the gradient of the variable set by the user.
  _convection_velocity[_qp] = _diffusion_gradient[_qp];
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="4352b232-eb99-4583-b4b5-e9b018ff38ee"><div class="modal-content"><h4>(moose/examples/ex08_materials/include/materials/ExampleMaterial.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;Material.h&quot;
#include &quot;LinearInterpolation.h&quot;

class ExampleMaterial : public Material
{
public:
  ExampleMaterial(const InputParameters &amp; parameters);

  static InputParameters validParams();

protected:
  virtual void computeQpProperties() override;

private:
  /// member variable to hold the computed diffusivity coefficient
  MaterialProperty&lt;Real&gt; &amp; _diffusivity;
  /// member variable to hold the computed convection velocity gradient term
  MaterialProperty&lt;RealGradient&gt; &amp; _convection_velocity;

  /// A place to store the coupled variable gradient for calculating the convection velocity
  /// property.
  const VariableGradient &amp; _diffusion_gradient;

  /// A helper object for performaing linear interpolations on tabulated data for calculating the
  /// diffusivity property.
  LinearInterpolation _piecewise_func;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="0143df39-68cc-45c6-afd8-1e36b5d05aec"><div class="modal-content"><h4>(moose/examples/ex08_materials/src/materials/ExampleMaterial.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ExampleMaterial.h&quot;

registerMooseObject(&quot;ExampleApp&quot;, ExampleMaterial);

InputParameters
ExampleMaterial::validParams()
{
  InputParameters params = Material::validParams();

  // Allow users to specify vectors defining the points of a piecewise function formed via linear
  // interpolation.
  params.addRequiredParam&lt;std::vector&lt;Real&gt;&gt;(
      &quot;independent_vals&quot;,
      &quot;The vector of z-coordinate values for a piecewise function&#x27;s independent variable&quot;);
  params.addRequiredParam&lt;std::vector&lt;Real&gt;&gt;(
      &quot;dependent_vals&quot;, &quot;The vector of diffusivity values for a piecewise function&#x27;s dependent&quot;);

  // Allow the user to specify which independent variable&#x27;s gradient to use for calculating the
  // convection velocity property:
  params.addCoupledVar(
      &quot;diffusion_gradient&quot;,
      &quot;The gradient of this variable will be used to compute a velocity vector property.&quot;);

  return params;
}

ExampleMaterial::ExampleMaterial(const InputParameters &amp; parameters)
  : Material(parameters),
    // Declare that this material is going to provide a Real value typed
    // material property named &quot;diffusivity&quot; that Kernels and other objects can use.
    // This property is &quot;bound&quot; to the class&#x27;s &quot;_diffusivity&quot; member.
    _diffusivity(declareProperty&lt;Real&gt;(&quot;diffusivity&quot;)),

    // Also declare a second &quot;convection_velocity&quot; RealGradient value typed property.
    _convection_velocity(declareProperty&lt;RealGradient&gt;(&quot;convection_velocity&quot;)),

    // Get the reference to the variable coupled into this Material.
    _diffusion_gradient(isCoupled(&quot;diffusion_gradient&quot;) ? coupledGradient(&quot;diffusion_gradient&quot;)
                                                        : _grad_zero),

    // Initialize our piecewise function helper with the user-specified interpolation points.
    _piecewise_func(getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;independent_vals&quot;),
                    getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;dependent_vals&quot;))
{
}

void
ExampleMaterial::computeQpProperties()
{
  // Diffusivity is the value of the interpolated piece-wise function described by the user
  _diffusivity[_qp] = _piecewise_func.sample(_q_point[_qp](2));

  // Convection velocity is set equal to the gradient of the variable set by the user.
  _convection_velocity[_qp] = _diffusion_gradient[_qp];
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="d2a97553-d521-42c2-ba51-1cb4025b51cd"><div class="modal-content"><h4>(moose/examples/ex08_materials/include/kernels/ExampleDiffusion.h)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#pragma once

#include &quot;Diffusion.h&quot;

class ExampleDiffusion : public Diffusion
{
public:
  ExampleDiffusion(const InputParameters &amp; parameters);

  /**
   * validParams returns the parameters that this Kernel accepts / needs
   * The actual body of the function MUST be in the .C file.
   */
  static InputParameters validParams();

protected:
  virtual Real computeQpResidual() override;
  virtual Real computeQpJacobian() override;

  /**
   * This MooseArray will hold the reference we need to our
   * material property from the Material class
   */
  const MaterialProperty&lt;Real&gt; &amp; _diffusivity;
};
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="9b921341-5bbb-4b48-905d-1848910bb7ca"><div class="modal-content"><h4>(moose/examples/ex08_materials/src/kernels/ExampleDiffusion.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ExampleDiffusion.h&quot;

/**
 * This function defines the valid parameters for
 * this Kernel and their default values
 */
registerMooseObject(&quot;ExampleApp&quot;, ExampleDiffusion);

InputParameters
ExampleDiffusion::validParams()
{
  InputParameters params = Diffusion::validParams();
  return params;
}

ExampleDiffusion::ExampleDiffusion(const InputParameters &amp; parameters)
  : Diffusion(parameters), _diffusivity(getMaterialProperty&lt;Real&gt;(&quot;diffusivity&quot;))
{
}

Real
ExampleDiffusion::computeQpResidual()
{
  // Reusing the Diffusion Kernel&#x27;s residual calculation
  return _diffusivity[_qp] * Diffusion::computeQpResidual();
}

Real
ExampleDiffusion::computeQpJacobian()
{
  // Reusing the Diffusion Kernel&#x27;s jacobian calculation
  return _diffusivity[_qp] * Diffusion::computeQpJacobian();
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="41e5f30e-ba06-4b37-8686-473abb037566"><div class="modal-content"><h4>(moose/examples/ex08_materials/src/materials/ExampleMaterial.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ExampleMaterial.h&quot;

registerMooseObject(&quot;ExampleApp&quot;, ExampleMaterial);

InputParameters
ExampleMaterial::validParams()
{
  InputParameters params = Material::validParams();

  // Allow users to specify vectors defining the points of a piecewise function formed via linear
  // interpolation.
  params.addRequiredParam&lt;std::vector&lt;Real&gt;&gt;(
      &quot;independent_vals&quot;,
      &quot;The vector of z-coordinate values for a piecewise function&#x27;s independent variable&quot;);
  params.addRequiredParam&lt;std::vector&lt;Real&gt;&gt;(
      &quot;dependent_vals&quot;, &quot;The vector of diffusivity values for a piecewise function&#x27;s dependent&quot;);

  // Allow the user to specify which independent variable&#x27;s gradient to use for calculating the
  // convection velocity property:
  params.addCoupledVar(
      &quot;diffusion_gradient&quot;,
      &quot;The gradient of this variable will be used to compute a velocity vector property.&quot;);

  return params;
}

ExampleMaterial::ExampleMaterial(const InputParameters &amp; parameters)
  : Material(parameters),
    // Declare that this material is going to provide a Real value typed
    // material property named &quot;diffusivity&quot; that Kernels and other objects can use.
    // This property is &quot;bound&quot; to the class&#x27;s &quot;_diffusivity&quot; member.
    _diffusivity(declareProperty&lt;Real&gt;(&quot;diffusivity&quot;)),

    // Also declare a second &quot;convection_velocity&quot; RealGradient value typed property.
    _convection_velocity(declareProperty&lt;RealGradient&gt;(&quot;convection_velocity&quot;)),

    // Get the reference to the variable coupled into this Material.
    _diffusion_gradient(isCoupled(&quot;diffusion_gradient&quot;) ? coupledGradient(&quot;diffusion_gradient&quot;)
                                                        : _grad_zero),

    // Initialize our piecewise function helper with the user-specified interpolation points.
    _piecewise_func(getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;independent_vals&quot;),
                    getParam&lt;std::vector&lt;Real&gt;&gt;(&quot;dependent_vals&quot;))
{
}

void
ExampleMaterial::computeQpProperties()
{
  // Diffusivity is the value of the interpolated piece-wise function described by the user
  _diffusivity[_qp] = _piecewise_func.sample(_q_point[_qp](2));

  // Convection velocity is set equal to the gradient of the variable set by the user.
  _convection_velocity[_qp] = _diffusion_gradient[_qp];
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="6b6beb8c-f580-47c6-b302-7f11cf4e8b47"><div class="modal-content"><h4>(moose/test/tests/materials/output/output_block.i)</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = FileMesh
  file = rectangle.e
  dim = 2
  uniform_refine = 1
[]

[Variables]
  [u]
  []
[]

[Kernels]
  [diff]
    type = CoefDiffusion
    variable = u
    coef = 0.5
  []
  [time]
    type = TimeDerivative
    variable = u
  []
[]

[BCs]
  [left]
    type = DirichletBC
    variable = u
    boundary = 1
    value = 0
  []
  [right]
    type = DirichletBC
    variable = u
    boundary = 2
    value = 2
  []
[]

[Materials]
  [block_1]
    type = OutputTestMaterial
    block = 1
    output_properties = &#x27;real_property tensor_property&#x27;
    outputs = exodus
    variable = u
  []
  [block_2]
    type = OutputTestMaterial
    block = 2
    output_properties = &#x27;vector_property tensor_property&#x27;
    outputs = exodus
    variable = u
  []
[]

[Executioner]
  type = Transient
  num_steps = 5
  dt = 0.1
  solve_type = PJFNK
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="ee73c8e5-ca1b-4f9e-90f5-9b44e22a1a90"><div class="modal-content"><h4>(moose/test/src/materials/ADCoupledVelocityMaterial.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;ADCoupledVelocityMaterial.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, ADCoupledVelocityMaterial);

InputParameters
ADCoupledVelocityMaterial::validParams()
{
  InputParameters params = FunctorMaterial::validParams();
  params.addRequiredParam&lt;MooseFunctorName&gt;(&quot;vel_x&quot;, &quot;the x velocity&quot;);
  params.addParam&lt;MooseFunctorName&gt;(&quot;vel_y&quot;, &quot;the y velocity&quot;);
  params.addParam&lt;MooseFunctorName&gt;(&quot;vel_z&quot;, &quot;the z velocity&quot;);
  params.addRequiredParam&lt;MooseFunctorName&gt;(&quot;rho&quot;, &quot;The name of the density variable&quot;);
  params.addClassDescription(&quot;A material used to create a velocity from coupled variables&quot;);
  params.addParam&lt;MaterialPropertyName&gt;(
      &quot;velocity&quot;, &quot;velocity&quot;, &quot;The name of the velocity material property to create&quot;);
  params.addParam&lt;MaterialPropertyName&gt;(
      &quot;rho_u&quot;, &quot;rho_u&quot;, &quot;The product of the density and the x-velocity component&quot;);
  params.addParam&lt;MaterialPropertyName&gt;(
      &quot;rho_v&quot;, &quot;rho_v&quot;, &quot;The product of the density and the y-velocity component&quot;);
  params.addParam&lt;MaterialPropertyName&gt;(
      &quot;rho_w&quot;, &quot;rho_w&quot;, &quot;The product of the density and the z-velocity component&quot;);
  params += SetupInterface::validParams();
  params.set&lt;ExecFlagEnum&gt;(&quot;execute_on&quot;) = {EXEC_ALWAYS};
  return params;
}

ADCoupledVelocityMaterial::ADCoupledVelocityMaterial(const InputParameters &amp; parameters)
  : FunctorMaterial(parameters),
    _vel_x(getFunctor&lt;ADReal&gt;(&quot;vel_x&quot;)),
    _vel_y(isParamValid(&quot;vel_y&quot;) ? &amp;getFunctor&lt;ADReal&gt;(&quot;vel_y&quot;) : nullptr),
    _vel_z(isParamValid(&quot;vel_z&quot;) ? &amp;getFunctor&lt;ADReal&gt;(&quot;vel_z&quot;) : nullptr),
    _rho(getFunctor&lt;ADReal&gt;(&quot;rho&quot;))
{
  const std::set&lt;ExecFlagType&gt; clearance_schedule(_execute_enum.begin(), _execute_enum.end());

  addFunctorProperty&lt;ADRealVectorValue&gt;(
      getParam&lt;MaterialPropertyName&gt;(&quot;velocity&quot;),
      [this](const auto &amp; r, const auto &amp; t) -&gt; ADRealVectorValue
      {
        ADRealVectorValue velocity(_vel_x(r, t));
        velocity(1) = _vel_y ? (*_vel_y)(r, t) : ADReal(0);
        velocity(2) = _vel_z ? (*_vel_z)(r, t) : ADReal(0);
        return velocity;
      },
      clearance_schedule);

  addFunctorProperty&lt;ADReal&gt;(
      getParam&lt;MaterialPropertyName&gt;(&quot;rho_u&quot;),
      [this](const auto &amp; r, const auto &amp; t) -&gt; ADReal { return _rho(r, t) * _vel_x(r, t); },
      clearance_schedule);

  addFunctorProperty&lt;ADReal&gt;(
      getParam&lt;MaterialPropertyName&gt;(&quot;rho_v&quot;),
      [this](const auto &amp; r, const auto &amp; t) -&gt; ADReal
      { return _vel_y ? _rho(r, t) * (*_vel_y)(r, t) : ADReal(0); },
      clearance_schedule);

  addFunctorProperty&lt;ADReal&gt;(
      getParam&lt;MaterialPropertyName&gt;(&quot;rho_w&quot;),
      [this](const auto &amp; r, const auto &amp; t) -&gt; ADReal
      { return _vel_z ? _rho(r, t) * (*_vel_z)(r, t) : ADReal(0); },
      clearance_schedule);
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="b40d9f0f-31bf-4ff3-9f4b-09b8bdefa564"><div class="modal-content"><h4>(moose/test/src/materials/RecomputeMaterial.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include &quot;RecomputeMaterial.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, RecomputeMaterial);

InputParameters
RecomputeMaterial::validParams()
{
  InputParameters params = Material::validParams();
  params.addRequiredParam&lt;std::string&gt;(&quot;f_name&quot;,
                                       &quot;The name of the property that holds the value to &quot;
                                       &quot;of the function for which the root is being &quot;
                                       &quot;computed&quot;);
  params.addRequiredParam&lt;std::string&gt;(
      &quot;f_prime_name&quot;,
      &quot;The name of the property that holds the value to of the derivative of the function&quot;);
  params.addRequiredParam&lt;std::string&gt;(&quot;p_name&quot;,
                                       &quot;The name of the independant variable for the function&quot;);
  params.addParam&lt;Real&gt;(&quot;constant&quot;, 0, &quot;The constant to add to the f equation.&quot;);
  params.set&lt;bool&gt;(&quot;compute&quot;) = false;
  return params;
}

RecomputeMaterial::RecomputeMaterial(const InputParameters &amp; parameters)
  : Material(parameters),
    _f(declareProperty&lt;Real&gt;(getParam&lt;std::string&gt;(&quot;f_name&quot;))),
    _f_prime(declareProperty&lt;Real&gt;(getParam&lt;std::string&gt;(&quot;f_prime_name&quot;))),
    _p(getMaterialProperty&lt;Real&gt;(getParam&lt;std::string&gt;(&quot;p_name&quot;))),
    _constant(getParam&lt;Real&gt;(&quot;constant&quot;))
{
}

void
RecomputeMaterial::resetQpProperties()
{
  _f[_qp] = 84;
  _f_prime[_qp] = 42;
}

// MOOSEDOCS_START
void
RecomputeMaterial::computeQpProperties()
{
  Real x = _p[_qp];
  _f[_qp] = x * x - _constant;
  _f_prime[_qp] = 2 * x;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="82d1e30d-d320-46a2-9bc2-a35c95933fb9"><div class="modal-content"><h4>(moose/test/src/materials/NewtonMaterial.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

// MOOSE includes
#include &quot;NewtonMaterial.h&quot;
#include &quot;Material.h&quot;

registerMooseObject(&quot;MooseTestApp&quot;, NewtonMaterial);

InputParameters
NewtonMaterial::validParams()
{
  InputParameters params = Material::validParams();
  params.addRequiredParam&lt;std::string&gt;(&quot;f_name&quot;,
                                       &quot;The name of the property that holds the value of &quot;
                                       &quot;the function for which the root is being &quot;
                                       &quot;computed&quot;);
  params.addRequiredParam&lt;std::string&gt;(
      &quot;f_prime_name&quot;,
      &quot;The name of the property that holds the value to of the derivative of the function&quot;);
  params.addRequiredParam&lt;std::string&gt;(&quot;p_name&quot;,
                                       &quot;The name of the independent variable for the function&quot;);
  params.addParam&lt;Real&gt;(&quot;tol&quot;, 1e-12, &quot;Newton solution tolerance.&quot;);
  params.addParam&lt;unsigned int&gt;(&quot;max_iterations&quot;, 42, &quot;The maximum number of Newton iterations.&quot;);
  params.addRequiredParam&lt;MaterialName&gt;(&quot;material&quot;, &quot;The material object to recompute.&quot;);
  return params;
}

NewtonMaterial::NewtonMaterial(const InputParameters &amp; parameters)
  : Material(parameters),
    _tol(getParam&lt;Real&gt;(&quot;tol&quot;)),
    _f(getMaterialProperty&lt;Real&gt;(getParam&lt;std::string&gt;(&quot;f_name&quot;))),
    _f_prime(getMaterialProperty&lt;Real&gt;(getParam&lt;std::string&gt;(&quot;f_prime_name&quot;))),
    _p(declareProperty&lt;Real&gt;(getParam&lt;std::string&gt;(&quot;p_name&quot;))),
    _max_iterations(getParam&lt;unsigned int&gt;(&quot;max_iterations&quot;))
{
}

void
NewtonMaterial::initialSetup()
{
  _discrete = &amp;getMaterial(&quot;material&quot;);
}

// MOOSEDOCS_START
void
NewtonMaterial::computeQpProperties()
{
  _p[_qp] = 0.5; // initial guess

  // Newton iteration for find p
  for (unsigned int i = 0; i &lt; _max_iterations; ++i)
  {
    _discrete-&gt;computePropertiesAtQp(_qp);
    _p[_qp] -= _f[_qp] / _f_prime[_qp];
    if (std::abs(_f[_qp]) &lt; _tol)
      break;
  }
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#bad0b500-1e7f-42a6-822c-2031803afa37" class="tooltipped" data-position="left" data-tooltip="Producing / Computing Properties">Producing / Computing Properties</a></li><li><a href="#16243602-fce1-420d-8833-5e67918eee3b" class="tooltipped" data-position="left" data-tooltip="Consuming Properties">Consuming Properties</a></li><li><a href="#ed1d99d1-a78c-4ac6-83bf-89128ffd3aa1" class="tooltipped" data-position="left" data-tooltip="Property Names">Property Names</a></li><li><a href="#39e0336f-fe42-4126-890a-c4a78541ff4f" class="tooltipped" data-position="left" data-tooltip="Default Material Properties">Default Material Properties</a></li><li><a href="#9d8404ef-23c6-440a-8f4f-2d2a2c4a2405" class="tooltipped" data-position="left" data-tooltip="Stateful Material Properties">Stateful Material Properties</a></li><li><a href="#1da59727-891f-4ff0-acfb-2958c075ebcd" class="tooltipped" data-position="left" data-tooltip="Material Property Output">Material Property Output</a></li><li><a href="#77c6cb13-0a5b-4dd3-b012-4043dac52122" class="tooltipped" data-position="left" data-tooltip="Material sorting">Material sorting</a></li><li><a href="#28e7a7f0-a862-4b31-b965-188f60da1f64" class="tooltipped" data-position="left" data-tooltip="Functor Material Properties">Functor Material Properties</a></li><li><a href="#52a46f80-c8f9-4b90-a37c-8ae240b8921f" class="tooltipped" data-position="left" data-tooltip="Advanced Topics">Advanced Topics</a></li><li><a href="#2dae7c89-ee30-4553-8ede-90c80e7c3f34" class="tooltipped" data-position="left" data-tooltip="Available Objects">Available Objects</a></li><li><a href="#c09195b6-774f-4f05-bcb9-c7ec69e9cee8" class="tooltipped" data-position="left" data-tooltip="Available Actions">Available Actions</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>